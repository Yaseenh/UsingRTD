%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{geometry}
\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Table of Contents}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}





\title{myTry Documentation}
\date{Mar 28, 2017}
\release{1.0}
\author{Yaseen}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\sphinxstylethead{\relax 
API Name
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax &\sphinxstylethead{\relax 
Link
\unskip}\relax \\
\hline
Account
&
Authentication, authorization and account managment
&
\href{http://secure.trackmatic.co.za/documentation/account.html}{Read More}
\\
\hline
Organisations
&
Organisation configuration and management
&
\href{http://secure.trackmatic.co.za/documentation/organisations.html}{Read More}
\\
\hline
Fleet
&
Asset and operator management
&
\href{http://secure.trackmatic.co.za/documentation/fleet.html}{Read More}
\\
\hline
Tracking
&
Live and historical asset tracking
&
\href{http://secure.trackmatic.co.za/documentation/tracking.html}{Read More}
\\
\hline
Loads (driver)
&
Load planning and execution
&
\href{http://secure.trackmatic.co.za/documentation/loads-drivers.html}{Read More}
\\
\hline
Loads (Integration)
&
Load planning and execution
&
\href{http://secure.trackmatic.co.za/documentation/loads-integration.html}{Read More}
\\
\hline
Blob Storage
&
Unstructured data storage and retrieval (File, Images etc)
&
\href{http://secure.trackmatic.co.za/documentation/blob-storage.html}{Read More}
\\
\hline
Web Hooks
&
Webhook subscriptions and management tools
&
\href{http://secure.trackmatic.co.za/documentation/webhooks.html}{Read More}
\\
\hline\end{tabulary}



\chapter{\sphinxstylestrong{Trackmatic}}
\label{\detokenize{index:welcome-to-trackmatic-api-s-documentation}}\label{\detokenize{index:trackmatic}}

\section{New Addition}
\label{\detokenize{newAmend:new-addition}}\label{\detokenize{newAmend::doc}}
This is supposed to be added in to the repo and should append to the pdf!
a change


\subsection{Trackmatic}
\label{\detokenize{newAmend:trackmatic}}

\section{Active Load}
\label{\detokenize{loads/drivers/loads/active-load:active-load}}\label{\detokenize{loads/drivers/loads/active-load::doc}}
The active load api call allows a driver to pull the current active load from the system. There can only ever be one active load for any given driver. If there is no current active load the API will return a 404 response indicating that there is no active load found.


\subsection{Allocation}
\label{\detokenize{loads/drivers/loads/active-load:allocation}}
The allocation describes the various components which have been allocated to the load. The allocation object is important when capturing odometer readings as the odometer configuration is defined for each asset in this section.


\subsection{Consignments}
\label{\detokenize{loads/drivers/loads/active-load:consignments}}
Header information about the consignment is enclosed in this section. It is intended to be used for display purposes only.


\subsection{Travel Plan}
\label{\detokenize{loads/drivers/loads/active-load:travel-plan}}
The travel plan describes what the driver has been requested to execute. The travel plan consists of two or more points of interest with activities to be executed at each one. The driver is expected to execute the load according to the sequence that the points of interest and activities appear in the message.


\subsection{Point of interest}
\label{\detokenize{loads/drivers/loads/active-load:point-of-interest}}
A point of interest represents the physical location which the driver is required to drive to in order to perform their activities. The point of interest contains an address which provides the relevant address information as well as the geofence data representing the physical geofence of the destination. The geofence can be used to test whether the driver has arrived or left a stop.


\subsection{Planned Path to}
\label{\detokenize{loads/drivers/loads/active-load:planned-path-to}}
The planned path represents the travel path to be taken from the previous stop to the current one and provides information on travel times and distance.


\subsection{Activities}
\label{\detokenize{loads/drivers/loads/active-load:activities}}
The activities describe what the driver needs to do when he/she arrives at a stop. A stop is made up of 0 or more activities. The execution sequence contains a list of the activity reference numbers and describes the order in which the activities should be executed. Each activity has 0 or more requiremnts.


\subsection{Requirements}
\label{\detokenize{loads/drivers/loads/active-load:requirements}}
A requirement defines the workflow and data which shoud be captured for every activity. The workflow for each activity should be built up from this metadata. The execution sequence contains a list of the requirement reference numbers and describes the order in which the requirements should be executed.


\section{Blob Storage}
\label{\detokenize{blob-storage/blob-storage:blob-storage}}\label{\detokenize{blob-storage/blob-storage::doc}}
The blob storage api provides a mechanism for callers to store or retrieve arbitrary unstructured data.


\subsection{Storing a file}
\label{\detokenize{blob-storage/blob-storage:storing-a-file}}
To store a file you need to perform an HTTP post with the Content-Type header set to ``multipart/form-data''. The endpoint expects one file per request. The file id must be provided by the caller. The following is required for a successfull upload

\sphinxcode{POST /api/v2/blob-storage/\{organisationId\}/\{fileId\}}
\begin{itemize}
\item {} 
A uniuque id must be provided in the url. If a file already exists with the supplied if an error will be thrown.

\item {} 
The Content-Type of the file must be provided and must be part of the supported content types listed below.

\item {} 
An organisation id which your token grants access to must be provided in the url

\end{itemize}


\subsubsection{Supported Content types}
\label{\detokenize{blob-storage/blob-storage:supported-content-types}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}application/xml\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}application/pdf\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}image/gif\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}image/png\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}image/jpeg\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}image/bmp\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}image/webp\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}text/plain\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}audio/midi\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}audio/mpeg\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}audio/webm\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}audio/ogg\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}audio/wav\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}video/webm\PYGZdq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}video/ogg\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Retrieving a file}
\label{\detokenize{blob-storage/blob-storage:retrieving-a-file}}
A file can be retrieved via an Http GET to the same URL used in the upload. A valid JWT token must be present.

\sphinxcode{GET /api/v2/blob-storage/\{organisationId\}/\{fileId\}}


\section{Import}
\label{\detokenize{loads/integration/import:import}}\label{\detokenize{loads/integration/import::doc}}
The import API provides a way to upload the complex load structure in a denormalized format. There are many moving parts to a load and care should be taken when building an integration to ensure a reliable and robust result.

Each message represents a single load along with all of its associated data. Once initial validation has been performed on the message the load is dispatched asynchrnously to be processed by the server. This means that the load may not be available immediately after a 200 response code is received. A web hook can be registered to notify you once the upload is complete.


\subsection{Validation}
\label{\detokenize{loads/integration/import:validation}}
The message you construct and send goes through a series of validation steps. The first phase does basic type checking and ensures that required fields have been provide. The next phase checks the referential integrity of the message. Lookup data is scanned for duplicates and lookup references are checked for consistency. If any failures are detected the API will respond with a ``400 Bad Request'' http status code. Details of the failure will be contained in the response message.


\subsection{Data Ownership}
\label{\detokenize{loads/integration/import:data-ownership}}
The data ownership component of the message is an important mechanism providing control over the ownership of various elements of the message. Using the data ownership component you are able to configure the behavior of the API for create, update and delete operations of the supported areas. The options for the operations are as follows:
\begin{itemize}
\item {} 
Accept - This will instruct the API to accept changes sent within the message and overwrite any data which already exists in the Trackmatic system. Using this option makes your system the owner of the data area.

\item {} 
Throw Error - This option will instruct the api to throw an error if the operation is attempted. This is useful when debugging or if you are not certain of the effect that the message will have on the data.

\item {} 
Ignore - When using this option the api will ignore any data sent by you if the data already exists in Trackmatic. This effectively makes Trackmatic the owner of the data area since once a component is created any further changes made by this api call will be ignored. This is usefull for when you need to allow chanegs to me made through the Trackmatic user interface and not have them overwritten by the integration.

\end{itemize}


\subsection{References}
\label{\detokenize{loads/integration/import:references}}
The various components are linked together by their respective references within the payload. The reference fields are intended to be populated with your business keys for the various elements of the payload. The reference number will follow the data through into the webhooks which will allow you to correlate the data in the webhook messages. The pattern is used throughout the message structure.

This process helps with deduplicating data within the payload. For example, when uploading a consignment with an associated entity, shipping address and geofence the payload would appear as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}geofences\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}geofence1\PYGZdq{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}\PYG{p}{,}

\PYG{l+s}{\PYGZdq{}shipping\PYGZus{}addresses\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}shippingAddress1\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}geofence\PYGZus{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}geofence1\PYGZdq{}}

    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}entities\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}entity1\PYGZdq{}}

    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}\PYG{p}{,}
\PYG{l+s}{\PYGZdq{}consignments\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
  \PYG{p}{\PYGZob{}}
    \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}consignment1\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}dropoffs\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
      \PYG{p}{\PYGZob{}}
        \PYG{l+s}{\PYGZdq{}entity\PYGZus{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}entity1\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}shipping\PYGZus{}address\PYGZus{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}shippingAddress1\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}dropoff1\PYGZdq{}}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{]}

    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{]}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}


\section{Session Management}
\label{\detokenize{loads/drivers/sessions/session-management:session-management}}\label{\detokenize{loads/drivers/sessions/session-management::doc}}
A driver must obtain a session before being able to perform any actions on the api. The session is used to bind the driver, asset and device together so the system knows Which device is being used to track which driver and asset.


\subsection{Retrieve an active session}
\label{\detokenize{loads/drivers/sessions/session-management:retrieve-an-active-session}}
\sphinxcode{GET /\{organisationId\}/sessions} can be used to retrieve an active session. If no active session exists a 404 result will be returned. Your app shoud check for an active session before trying to create a new one.


\subsection{Creating a session}
\label{\detokenize{loads/drivers/sessions/session-management:creating-a-session}}
The following api call will allow you to create a new session which binds the currently logged in user to the asset and device provided. Any attempt to create a new session with any combination of the below will cause an error to be thrown.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{POST} \PYG{p}{/}\PYG{p}{\PYGZob{}}\PYG{n}{organiastionId}\PYG{p}{\PYGZcb{}}\PYG{p}{/}\PYG{n}{sessions}

\PYG{p}{\PYGZob{}}
   \PYG{l+s}{\PYGZdq{}asset\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{,}
   \PYG{l+s}{\PYGZdq{}device\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Revoking a session}
\label{\detokenize{loads/drivers/sessions/session-management:revoking-a-session}}
If a session was created by mistake or the driver wishes to manually release the session you can do this via the following api call. A reason for revoking the session must be provided.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PUT} \PYG{p}{/}\PYG{p}{\PYGZob{}}\PYG{n}{organiastionId}\PYG{p}{\PYGZcb{}}\PYG{p}{/}\PYG{n}{sessions}\PYG{p}{\PYGZob{}}\PYG{n}{sessionId}\PYG{p}{\PYGZcb{}}\PYG{p}{/}\PYG{n}{revoke}

\PYG{p}{\PYGZob{}}
   \PYG{l+s}{\PYGZdq{}reason\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Closing a session}
\label{\detokenize{loads/drivers/sessions/session-management:closing-a-session}}
A session shoud be closed only once all data has been flushed from the store and forward mechanism. Closing a session before that could result in data loss.

\sphinxcode{PUT /\{organiastionId\}/sessions\{sessionId\}/close}


\section{Webhook Payloads}
\label{\detokenize{loads/web-hooks/payloads:webhook-payloads}}\label{\detokenize{loads/web-hooks/payloads::doc}}

\subsection{Load Activated \sphinxstyleliteralintitle{load.activated}}
\label{\detokenize{loads/web-hooks/payloads:load-activated-load-activated}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{l+s}{\PYGZdq{}when\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}2017\PYGZhy{}03\PYGZhy{}23T08:32:10.069287Z\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}where\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+m}{0}\PYG{p}{,} \PYG{l+m}{0} \PYG{p}{]}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}load\PYGZus{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}requested\PYGZus{}date\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}2017\PYGZhy{}03\PYGZhy{}23T08:30:50.2078258Z\PYGZdq{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}allocation\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
    \PYG{l+s}{\PYGZdq{}driver\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}vehicle\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s}{\PYGZdq{}id\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}reference\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}registration\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}fleet\PYGZus{}number\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}assets\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{l+s}{\PYGZdq{}accessories\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s}{\PYGZdq{}pallet\PYGZus{}jack\PYGZdq{}}\PYG{p}{:} \PYG{k}{null}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}load\PYGZus{}lock\PYGZus{}rails\PYGZdq{}}\PYG{p}{:} \PYG{l+m}{0}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}fuel\PYGZus{}card\PYGZdq{}}\PYG{p}{:} \PYG{k}{null}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Pickup Started \sphinxstyleliteralintitle{load.pickup.started}}
\label{\detokenize{loads/web-hooks/payloads:pickup-started-load-pickup-started}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\subsection{Pickup Completed \sphinxstyleliteralintitle{load.pickup.completed}}
\label{\detokenize{loads/web-hooks/payloads:pickup-completed-load-pickup-completed}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\subsection{Dropoff Started \sphinxstyleliteralintitle{load.dropoff.started}}
\label{\detokenize{loads/web-hooks/payloads:dropoff-started-load-dropoff-started}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\subsection{Dropoff Completed \sphinxstyleliteralintitle{load.dropoff.completed}}
\label{\detokenize{loads/web-hooks/payloads:dropoff-completed-load-dropoff-completed}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}


\section{Webhooks}
\label{\detokenize{webhooks/web-hooks:webhooks}}\label{\detokenize{webhooks/web-hooks::doc}}
The webhooks api allows you to subscribe to events which occur within the various modules of the Trackmatic system. An Http POST is performed against the provided URI when an event occurs which matches your provided subscription details.


\subsection{Subscriptions}
\label{\detokenize{webhooks/web-hooks:subscriptions}}
A subscription lets you tell Trackmatic which Http endpoint to call when one or more event types are matched. A subscrition takes the following form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
 \PYG{l+s}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s}{\PYGZdq{}uri\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s}{\PYGZdq{}is\PYGZus{}active\PYGZdq{}}\PYG{p}{:} \PYG{k}{true}\PYG{p}{,}
 \PYG{l+s}{\PYGZdq{}events\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
   \PYG{l+s}{\PYGZdq{}string\PYGZdq{}}
 \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

When an event is raised within Trackmatic a callback is dispatched which will attempt to perform a POST against the URI provided in the subscription.

You can create a single subscription which can match on one or more event types. In this configuration you can make use of the http headers in the request to correctly route and interpret the payload. Alternatively you can configure a subscription per event type.

Subscriptions can be managed from the subscriptions api as per below

\sphinxcode{api/v2/webhooks/subscriptions}


\subsection{Payload format}
\label{\detokenize{webhooks/web-hooks:payload-format}}
The format of the payload is specific to each event type. Http headers are appended to each request in order to assist you in determining how to interpret the payload. The following http headers are appended to each request:

\noindent\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\sphinxstylethead{\relax 
Header Name
\unskip}\relax &\sphinxstylethead{\relax 
Description
\unskip}\relax &\sphinxstylethead{\relax 
Mandatory
\unskip}\relax \\
\hline
x-tm-event-name
&
The name of the event which triggered the callback
&
Yes
\\
\hline
x-tm-correlation-id
&
A correlation id may be supplied which can correlate one or more events together
&
No
\\
\hline
x-tm-site-id
&
When an event is site specific the site id will be provided
&
No
\\
\hline
x-tm-organisation-id
&
Indicates which organisation the event was raised on
&
Yes
\\
\hline
x-tm-aggregate-id
&
The id of the entity which raised the event. The entity type can be inffered from the event name
&
Yes
\\
\hline\end{tabulary}



\subsection{Failures and Retries}
\label{\detokenize{webhooks/web-hooks:failures-and-retries}}
The webhook system is designed to be fault tolerant with at least one delivery of a given payload. Depending on the failure condition it is possible a a message to be delivered more than once and you application will need to deal with this eventuality.

The retry mechnism works as follows:
\begin{enumerate}
\item {} 
If a callback fails it will be attempted up to 5 times with no delay between messages

\item {} 
If the callback is still failing after the above 5 attempts the message will be delayed for 15 minutes before the next retry attempt

\item {} 
If the callback continues to fail it will retry with a delay increasing in 15 minute increments up to a maximum of 20 times

\item {} 
The message will be retried in this fashion for roughly 24 hours. If the callback is still failing after this period it will be marked as failed in our system and retry attempts will stop

\item {} 
Failed messages can be retrieved via the /logs endpoint for any given subscription should you require to manually replay the message.

\end{enumerate}


\subsection{Logging \& Debugging}
\label{\detokenize{webhooks/web-hooks:logging-debugging}}
All callbacks and dispatch attempts are logged and can be retrieved via n
\sphinxcode{api/v2/webhooks/\{organisation\_id\}/subscriptions/logs?take=128\&skip=0}

The logs are useful for determining if an event was raised for a given subscription, what the payload being sent was and what the response from your system was.

The response from the logging endpoint is intentionally unstructured since the request and payload information can be different depending on the event type.



\renewcommand{\indexname}{Index}
\printindex
\end{document}